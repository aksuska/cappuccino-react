{"version":3,"sources":["../../src/Foundation/CPMethodSignature.js"],"names":["CPMethodSignature","methodReturnType","$$typeList","anything","methodReturnLength","numberOfArguments","length","frameLength","signatureWithObjCTypes_","typeString","sig","new","split","getArgumentTypeAtIndex_","idx","className","isOneway"],"mappings":";;;;;;AAOA;;AACA;;;;;;AARA;;;;;;;AAUe,MAAMA,iBAAN,4BAAyC;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,UAE1C;AAF0C;AAAA;;AAIvD,KAAIC,gBAAJ,GAAuB;AAAC,SAAO,KAAKC,UAAL,CAAgB,CAAhB,CAAP;AAA2B;AACnD,KAAID,gBAAJ,CAAqBE,QAArB,EAA+B;AAAC,kCAAe,iCAAf;AAAmD;;AAEnF,KAAIC,kBAAJ,GAAyB;AAAC,SAAO,CAAP;AAAU;AACpC,KAAIA,kBAAJ,CAAuBD,QAAvB,EAAiC;AAAC,kCAAe,iCAAf;AAAmD;;AAErF,KAAIE,iBAAJ,GAAwB;AAAC,SAAO,KAAKH,UAAL,CAAgBI,MAAhB,GAAyB,CAAhC;AAAmC;AAC5D,KAAID,iBAAJ,CAAsBF,QAAtB,EAAgC;AAAC,kCAAe,iCAAf;AAAmD;;AAEpF,KAAII,WAAJ,GAAkB;AAAC,SAAO,CAAP;AAAU;AAC7B,KAAIA,WAAJ,CAAgBJ,QAAhB,EAA0B;AAAC,kCAAe,iCAAf;AAAmD;;AAE9E,QAAOK,uBAAP,CAA+BC,UAA/B,EAA2C;AAC1C,MAAIC,MAAM,KAAKC,GAAL,EAAV;AACA,MAAID,GAAJ,EAAS;AACRA,OAAIR,UAAJ,GAAiBO,WAAWG,KAAX,CAAiB,EAAjB,CAAjB;AACA;AACD,SAAOF,GAAP;AACA;;AAEDG,yBAAwBC,GAAxB,EAA6B;AAC5B,MAAIA,OAAO,KAAKZ,UAAL,CAAgBI,MAA3B,EACC,gCAAgB,iEAAhB,EAAmF,KAAKS,SAAxF,EAAmGD,GAAnG,EAAwG,KAAKZ,UAAL,CAAgBI,MAAhB,GAAyB,CAAjI;;AAED,SAAO,KAAKJ,UAAL,CAAgBY,GAAhB,CAAP;AACA;;AAED;AACAE,YAAW;AACV,SAAO,IAAP;AACA;AAlCsD;kBAAnChB,iB","file":"CPMethodSignature.js","sourcesContent":["/**\n * Implementation of NSMethodSignature. Not generally useful since there is a lot if functionality\n * we can't easily replicate. If it became necessary it might be possible to have the compiler annotate\n * inside the function declaration so as to preserve the type annotations, which would be accessible\n * via the toString() method of Function.\n **/\n\nimport {objj_throw_arg} from '../Objective-J';\nimport CPObject from './CPObject';\n\nexport default class CPMethodSignature extends CPObject {\n\t\n\t$$typeList = [];\n\t\n\tget methodReturnType() {return this.$$typeList[0];}\n\tset methodReturnType(anything) {objj_throw_arg(\"Assignment to readonly property\");}\n\n\tget methodReturnLength() {return 1;}\n\tset methodReturnLength(anything) {objj_throw_arg(\"Assignment to readonly property\");}\n\n\tget numberOfArguments() {return this.$$typeList.length - 1;}\n\tset numberOfArguments(anything) {objj_throw_arg(\"Assignment to readonly property\");}\n\n\tget frameLength() {return 1;}\n\tset frameLength(anything) {objj_throw_arg(\"Assignment to readonly property\");}\n\n\tstatic signatureWithObjCTypes_(typeString) {\n\t\tlet sig = this.new();\n\t\tif (sig) {\n\t\t\tsig.$$typeList = typeString.split('');\n\t\t}\n\t\treturn sig;\n\t}\n\t\n\tgetArgumentTypeAtIndex_(idx) {\n\t\tif (idx >= this.$$typeList.length)\n\t\t\tobjj_throw_arg( \"-[%@ getArgumentTypeAtIndex:]: index (%i) out of bounds [0, %i]\", this.className, idx, this.$$typeList.length - 1);\n\t\t\n\t\treturn this.$$typeList[idx];\n\t}\n\t\n\t// N/A but true is usually the right answer\n\tisOneway() {\n\t\treturn true;\n\t}\n}\n"]}